"use strict";(self.webpackChunkubc_services=self.webpackChunkubc_services||[]).push([[428],{28453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>o});var t=i(96540);const s={},r=t.createContext(s);function a(e){const n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),t.createElement(r.Provider,{value:n},e.children)}},40288:(e,n,i)=>{i.d(n,{A:()=>t});const t=i.p+"assets/images/image_001-5889cc6e7b4c7181a3d1618d4e571602.png"},60532:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>c,frontMatter:()=>a,metadata:()=>t,toc:()=>p});const t=JSON.parse('{"id":"MAP/documentation","title":"Mapping framework (UBC.map)","description":"Intro","source":"@site/docs/products/UBC/MAP/documentation.md","sourceDirName":"MAP","slug":"/MAP/documentation","permalink":"/products/UBC/MAP/documentation","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"ubc","previous":{"title":"RESTful webservices (UBC.rest)","permalink":"/products/UBC/REST/documentation"},"next":{"title":"UBC Business objects (UBC.bo)","permalink":"/products/UBC/BO/documentation"}}');var s=i(74848),r=i(28453);const a={},o="Mapping framework (UBC.map)",l={},p=[{value:"Intro",id:"intro",level:2},{value:"Mapping",id:"mapping",level:2},{value:"Mapping Fields",id:"mapping-fields",level:3},{value:"Submappings",id:"submappings",level:3},{value:"Conversions",id:"conversions",level:3},{value:"Mapping Process Flow",id:"mapping-process-flow",level:3},{value:"Data Grouping",id:"data-grouping",level:3},{value:"Data Grouping Process",id:"data-grouping-process",level:3},{value:"Customizing",id:"customizing",level:2},{value:"Mapping Configuration",id:"mapping-configuration",level:3},{value:"Field Mapping Configuration",id:"field-mapping-configuration",level:3},{value:"Data Grouping Configuration",id:"data-grouping-configuration",level:3},{value:"Integration with other UBC components",id:"integration-with-other-ubc-components",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"mapping-framework-ubcmap",children:"Mapping framework (UBC.map)"})}),"\n",(0,s.jsx)(n.h2,{id:"intro",children:"Intro"}),"\n",(0,s.jsx)(n.p,{children:"UBC - Unified Backend Connector comes with a flexible mapping framework component that enables transformation between different message formats and data structures. The mapping framework provides a standardized approach to handle various mapping scenarios within your SAP environment, making cross-system data exchange more manageable."}),"\n",(0,s.jsx)(n.h2,{id:"mapping",children:"Mapping"}),"\n",(0,s.jsx)(n.p,{children:"The UBC.map framework provides multiple approaches to mapping data between different structures and tables. These mapping strategies can be configured to meet specific requirements:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Field-specific Mapping"}),": Maps individual fields from source to target structures with precise control over data transformation at the field level."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Corresponding Field Mapping"}),": Automatically maps fields with matching names or keys between source and target structures, streamlining the mapping process for similar data models."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Table Iteration Mapping"}),": Processes tables by iterating through each line and applying configured mapping rules, enabling complex transformations of tabular data."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"These mapping approaches can be used independently or in combination to address various mapping operations, from simple data transfers to complex cross-system transformations."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-abap",children:"\" Simple structure mapping\nDATA: lo_mapping TYPE REF TO /ubc/if_mp_mapping,\n      ls_source  TYPE sflight,\n      ls_target  TYPE ty_order.\n\nSELECT SINGLE * FROM sflight \n  INTO @ls_source\n  WHERE carrid = 'LH' AND connid = '0400'.\n\nTRY.\n    lo_mapping = /ubc/cl_mp_mapping=>create_instance( 'Z_FLIGHT_TO_ORDER' ).\n    \n    lo_mapping->process(\n      EXPORTING iv_input  = ls_source\n      IMPORTING ev_output = ls_target ).\n      \nCATCH /ubc/cx_map INTO DATA(lx_error).\n    MESSAGE lx_error TYPE 'E'.\nENDTRY.\n\n\" Table-to-Table mapping\nDATA: lt_flights TYPE TABLE OF sflight,\n      lt_orders  TYPE TABLE OF ty_order_item.\n\nSELECT * FROM sflight \n  INTO TABLE @lt_flights\n  WHERE carrid = 'LH' \n    AND fldate >= '20250101'.\n\nTRY.\n    lo_mapping = /ubc/cl_mp_mapping=>create_instance( 'Z_FLIGHTS_TO_ORDERS' ).\n    \n    lo_mapping->process(\n      EXPORTING iv_input  = lt_flights\n      IMPORTING ev_output = lt_orders ).\n      \nCATCH /ubc/cx_map INTO DATA(lx_tab_error).\n    MESSAGE lx_tab_error TYPE 'E'.\nENDTRY.\n"})}),"\n",(0,s.jsx)(n.h3,{id:"mapping-fields",children:"Mapping Fields"}),"\n",(0,s.jsx)(n.p,{children:"Field mapping defines the precise relationships between source and target data elements. UBC.map supports several mapping types to accommodate different transformation requirements:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Constant Mapping"}),": Assigns a literal value directly to a target field, useful for setting default values or standardizing data across records."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Full Source Mapping"}),": Maps an entire source structure to a target field rather than mapping individual elements, enabling complex structure transformations."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Full Target Mapping"}),": Maps a source field to an entire target structure, facilitating the population of multiple target fields from a single source element."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Each mapping can optionally incorporate a conversion operation that transforms the data during the mapping process. These conversions can handle type transformations, format standardizations, or complex business logic as required from the mapping operation."}),"\n",(0,s.jsx)(n.h3,{id:"submappings",children:"Submappings"}),"\n",(0,s.jsx)(n.p,{children:"Submappings extend the mapping framework to handle nested data structures and complex hierarchical relationships. When mapping operations require transformation of nested elements, submappings provide a structured approach to defining these relationships."}),"\n",(0,s.jsx)(n.p,{children:"A submapping is a complete mapping configuration that is associated with a specific mapping field. This allows complex structures to be mapped with the same flexibility and precision as top-level elements, maintaining data integrity throughout the transformation process."}),"\n",(0,s.jsx)(n.p,{children:"Submappings are particularly valuable when working with:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Complex JSON or XML structures with multiple nesting levels"}),"\n",(0,s.jsx)(n.li,{children:"Business objects containing child components or line items"}),"\n",(0,s.jsx)(n.li,{children:"Mapping operations requiring partial structure transformations within larger data sets"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"By supporting nested mapping definitions, UBC.map enables comprehensive data transformations regardless of structural complexity."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"Mapping submapping configuration",src:i(40288).A+"",width:"3938",height:"1614"})}),"\n",(0,s.jsx)(n.h3,{id:"conversions",children:"Conversions"}),"\n",(0,s.jsx)(n.p,{children:"The UBC.map framework provides standardized conversion capabilities that ensure data consistency when transferring information between systems with different formatting requirements:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Unit Conversions"}),": Automatically transforms measurement values (i.e. imperial to and from metric) between systems, ensuring consistent data representation across regional boundaries."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Datetime Conversions"}),": Handles transformation of timestamp data between various formats, standardizing datetime representations for seamless integration between systems (like erp and mes) with different time handling conventions."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Alpha Conversions"}),": Manages alphabetic character set transformations and normalizations, supporting multi-language compatibility and character encoding adjustments across systems."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsxs)(n.strong,{children:[(0,s.jsx)(n.a,{href:"https://qppd.info/",children:"QPPD"})," to SAP Standard Conversions"]}),": Converts Quality, Production, Planning and Distribution (QPPD) specific formats to SAP standard formats, enabling smooth integration between specialized industry solutions and core SAP processes."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"These conversion capabilities are part of the broader mapping process."}),"\n",(0,s.jsx)(n.h3,{id:"mapping-process-flow",children:"Mapping Process Flow"}),"\n",(0,s.jsx)(n.mermaid,{value:"flowchart TD\n    A[Input structure] --\x3e B[Mapping Framework]\n    B --\x3e C{Keep corresponding fields?}\n    \n    C --\x3e|Yes| D[Auto-map matching fields to output]\n    C --\x3e|No| E[Process configured field mappings]\n    D --\x3e E\n    \n    E --\x3e F{For each field mapping}\n    F --\x3e G{Mapping type?}\n    \n    G --\x3e|Constant| H[Assign literal value to target field]\n    G --\x3e|Regular Field| I[Extract source field value]\n    G --\x3e|Full From| J[Pass entire input structure to single target field]\n    G --\x3e|Full To| K[Extract single field value]\n    G --\x3e|Submapping| L[Extract nested structure]\n    \n    I --\x3e M{Conversion specified?}\n    M --\x3e|Yes| N[Apply conversion transformation]\n    M --\x3e|No| O[Assign to target field]\n    N --\x3e O\n    \n    K --\x3e P[Expand to entire target structure]\n    \n    L --\x3e Q[Process with submapping ID]\n    Q --\x3e R[Return transformed structure]\n    R --\x3e S[Assign to target field/structure]\n    \n    H --\x3e T{More field mappings?}\n    O --\x3e T\n    P --\x3e T\n    S --\x3e T\n    J --\x3e T\n    \n    T --\x3e|Yes| F\n    T --\x3e|No| U[Complete transformed data structure]\n    U --\x3e V[Output structure]\n    \n    style A fill:#e1f5fe\n    style V fill:#e8f5e8\n    style B fill:#fff3e0\n    style Q fill:#f3e5f5"}),"\n",(0,s.jsx)(n.h3,{id:"data-grouping",children:"Data Grouping"}),"\n",(0,s.jsx)(n.p,{children:"Data tables can be dynamically sorted and grouped according to fields specified in customizing. UBC.map provides flexible data grouping capabilities that can be configured through grouping IDs in the customizing transaction."}),"\n",(0,s.jsx)(n.p,{children:"The Data Grouping functionality supports:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Grouping by single or multiple fields"}),"\n",(0,s.jsx)(n.li,{children:"Automatic sorting of data based on grouping fields"}),"\n",(0,s.jsx)(n.li,{children:"Dynamic result structure generation based on input data"}),"\n",(0,s.jsx)(n.li,{children:"Access to both the grouped data and grouping metadata"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Each grouped result contains:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The grouping value (concatenated from the grouping fields)"}),"\n",(0,s.jsx)(n.li,{children:"The list of fields used for grouping"}),"\n",(0,s.jsx)(n.li,{children:"The subset of data that belongs to that group"}),"\n"]}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsx)(n.p,{children:"The grouping result structure is dynamically generated based on the input data structure, with fields for the grouping metadata plus a DATA component containing the grouped records."})}),"\n",(0,s.jsx)(n.p,{children:"This powerful feature enables efficient data organization and processing for downstream operations, particularly useful when dealing with complex hierarchical data structures or when preparing data for batch processing."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-abap",children:"\" Data grouping with multiple fields\nDATA: lt_flights  TYPE TABLE OF sflight,\n      lo_grouping TYPE REF TO /ubc/if_bc_data_grouping,\n      lo_result   TYPE REF TO data.\n\nFIELD-SYMBOLS: <lt_grouped> TYPE STANDARD TABLE.\n\nSELECT * FROM sflight \n  INTO TABLE @lt_flights\n  WHERE carrid IN ('LH', 'AF') \n    AND fldate BETWEEN '20250101' AND '20250131'.\n\nTRY.\n    lo_grouping = /ubc/cl_bc_data_grouping=>create_instance( 'Z_FLIGHTS_BY_CARRIER_CONN' ).\n    \n    DATA(lo_result_type) = lo_grouping->get_result_type( lt_flights ).\n    CREATE DATA lo_result TYPE HANDLE lo_result_type.\n    ASSIGN lo_result->* TO <lt_grouped>.\n    \n    lo_grouping->group_data(\n      EXPORTING it_data = lt_flights\n      IMPORTING et_data = <lt_grouped>\n    ).\n    \nCATCH /ubc/cx_bc_data_grouping INTO DATA(lx_error).\n    MESSAGE lx_error TYPE 'E'.\nENDTRY.\n"})}),"\n",(0,s.jsx)(n.h3,{id:"data-grouping-process",children:"Data Grouping Process"}),"\n",(0,s.jsx)(n.mermaid,{value:"flowchart TD\n    A[Input Table] --\x3e B[Data Grouping Framework]\n    B --\x3e C[Sort table by grouping fields]\n    C --\x3e D[Initialize empty result table]\n    \n    D --\x3e E{Process each record}\n    E --\x3e F[Extract values from grouping fields]\n    F --\x3e G[Create composite grouping value]\n    \n    G --\x3e H{Group already exists?}\n    \n    H --\x3e|Yes| I[Add record to existing group's DATA table]\n    H --\x3e|No| J[Create new group structure]\n    J --\x3e K[Initialize group metadata]\n    K --\x3e L[Add record to new group's DATA table]\n    L --\x3e M[Add new group to result table]\n    \n    I --\x3e N{More records?}\n    M --\x3e N\n    \n    N --\x3e|Yes| E\n    N --\x3e|No| O[Return grouped result table]\n    O --\x3e P[Output: Table of grouped structures]\n    \n    subgraph \"Result structure example\"\n        Q[Group 1]\n        R[Group 2]\n        \n        Q --\x3e Q1[grouping_value: 'Material-A']\n        Q --\x3e Q2[grouping_fields: 'MATNR']\n        Q --\x3e Q3[DATA: Table of records]\n        \n        R --\x3e R1[grouping_value: 'Material-B']\n        R --\x3e R2[grouping_fields: 'MATNR']\n        R --\x3e R3[DATA: Table of records]\n    end\n    \n    P -.-> Q\n    \n    style A fill:#e1f5fe\n    style P fill:#e8f5e8\n    style B fill:#fff3e0\n    style Q fill:#f5f5f5\n    style R fill:#f5f5f5"}),"\n",(0,s.jsx)(n.h2,{id:"customizing",children:"Customizing"}),"\n",(0,s.jsxs)(n.p,{children:["Define and configure your mapping rules through customizing. Similar to other UBC components, mapping configurations can be accessed through the UBC customizing transaction ",(0,s.jsx)(n.code,{children:"/UBC/MAPPING_C"})," where you can define your mappings, groupings, parsings and assign source and target structures and their relationships. Additionally active and inactive mappings, groupings, conversions can be displayed with ",(0,s.jsx)(n.code,{children:"/UBC/MAPPING_D"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"mapping-configuration",children:"Mapping Configuration"}),"\n",(0,s.jsx)(n.p,{children:"Configure mappings by creating a mapping entry with a unique ID. This entry serves as the foundation for all related field mappings and defines the general processing behavior:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Table-to-Table Relation"}),": When enabled, the mapping will iterate through each row of the input table and apply field mappings to each record individually. Without this setting, the mapping processes a single structure. This corresponds to the ",(0,s.jsx)(n.code,{children:"table_to_table"})," flag in the mapping definition."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Keep Corresponding Fields"}),": When enabled, the system will automatically use ABAP's ",(0,s.jsx)(n.code,{children:"CORRESPONDING"})," operator to map fields with matching names before applying your custom field mappings. This is useful for structures with many matching field names to reduce the number of explicit mappings required."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsx)(n.p,{children:'If you\'re mapping between similar structures with mostly matching field names, enable "Keep Corresponding Fields" and only define mappings for fields that need special handling.'})}),"\n",(0,s.jsx)(n.h3,{id:"field-mapping-configuration",children:"Field Mapping Configuration"}),"\n",(0,s.jsx)(n.p,{children:"For each mapping ID, define individual field mappings in the field mapping tab. Each field mapping specifies:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"From Field"}),": The source field in the input structure"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"To Field"}),": The target field in the output structure"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Mapping Type: Control how the field values are processed:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Constant Mapping"}),': The value in "From Field" is treated as a literal constant and assigned directly to the target field without looking up a value in the input structure. Useful for setting fixed values, defaults, or parameters.']}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Full From Mapping"}),": Maps the entire input structure to the specified target field. This assigns the complete input structure reference to a single field in the output structure, useful when storing a complex structure within a single field."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Full To Mapping"}),": Maps a single source field to the entire output structure. This is useful when a source field contains data that needs to expand into the entire target structure."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Regular Field Mapping"}),": (when none of the above are set) Maps a single field from input to output, applying any specified conversions."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Submapping"}),": Specify another mapping ID to process nested structures. When specified, the system creates a new mapping instance for the substructure and applies it to transform the nested data between the source and target fields."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Conversion Options:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Conversion"}),": Assign a standard conversion (unit, datetime, alpha, QPPD) to transform the data during mapping."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Conversion Mapping"}),": Specify a custom conversion method for complex transformations requiring business logic."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.admonition,{type:"warning",children:(0,s.jsx)(n.p,{children:'When using "Full From" or "Full To" options, ensure that the target/source field can accept the complete structure type. These options bypass normal field-level mapping and work directly with structure references.'})}),"\n",(0,s.jsx)(n.h3,{id:"data-grouping-configuration",children:"Data Grouping Configuration"}),"\n",(0,s.jsx)(n.p,{children:"Data grouping organizes table data into logical groups based on field values. Configure data grouping in the grouping configuration tab:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Create a grouping entry with a unique grouping ID"}),"\n",(0,s.jsx)(n.li,{children:"Define the fields to be used as grouping criteria in the grouping fields tab"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The data grouping functionality is particularly useful for:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Processing related records together (e.g., all items for the same order)"}),"\n",(0,s.jsx)(n.li,{children:"Creating hierarchical views of flat data"}),"\n",(0,s.jsx)(n.li,{children:"Preparing data for reporting or batch processing"}),"\n",(0,s.jsx)(n.li,{children:"Organizing data before further transformation steps"}),"\n"]}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsx)(n.p,{children:"When defining grouping fields, arrange them in logical order from general to specific (e.g., Order Number, then Item Number) for optimal sorting and grouping results."})}),"\n",(0,s.jsx)(n.h2,{id:"integration-with-other-ubc-components",children:"Integration with other UBC components"}),"\n",(0,s.jsx)(n.p,{children:'UBC.map functions as a critical transformation layer in the UBC ecosystem, positioned as "Data to Process to Data" in the architecture. It serves as a bridge between various UBC components:'}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"UBC.act"}),": Transforms data from SAP standard or custom objects into formats needed by other components"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"UBC.flow"}),": Provides data transformations required for workflow processing steps"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"UBC.rest"}),": Converts between external integration formats and internal data structures"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"UBC.io"}),": Supports cross-layer monitoring by ensuring data consistency across the platform"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"UBC.map handles both transactional data (such as Sales Orders, Financial Documents, Purchase Orders) and master data (Business Partners, Material Masters, Product Specifications) transformations, enabling seamless data flow throughout the system. This component is essential for maintaining data integrity while information moves between different processing stages and system boundaries."})]})}function c(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);